<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*       on 2022-06-23T15:01:59-04:00       *-->
<!--*   A recent stable commit (2020-08-09):   *-->
<!--* 98f21740783f166a773df4dc83cab5293ab63a4a *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<h4 class="heading"><span class="type">Paragraph</span></h4>
<p>There is one more item to address before we implement the GGH cryptosystem. That item is how to solve the Closest Vector Problem. There are some algorithms for approximating the closest vector in a basis. One is Babai's Closest Vector algorithm. This algorithm works in the following way. Consider a lattice with basis <span class="process-math">\(\{\vb_1, \vb_2, \ldots, \vb_n\}\text{.}\)</span> To approximate the closest vector in the lattice to a vector <span class="process-math">\(\vw\text{,}\)</span> find the weights <span class="process-math">\(c_1\text{,}\)</span> <span class="process-math">\(c_2\text{,}\)</span> <span class="process-math">\(\ldots\text{,}\)</span> <span class="process-math">\(c_n\)</span> in <span class="process-math">\(\R\)</span> such that <span class="process-math">\(\vw = c_1\vb_1 + c_2 \vb_2 + \cdots + c_n \vb_n\text{.}\)</span> Then round the coefficients to the nearest integer. This algorithm works well for a good basis, but is unlikely to return a lattice point that is close to <span class="process-math">\(\vw\)</span> if the basis is a bad one.</p>
<span class="incontext"><a href="chap_bases_dimension.html#p-2693" class="internal">in-context</a></span>
</body>
</html>
